Использование хаскеля для этой задачи оправдано, так как эти обёртки над 
wpa_supplicant — на самом деле являются системным софтом. Они постоянно висят в 
памяти, поэтому её расход должен быть оптимизирован.

Эта пара скриптов является скорее продолжением пользовательских конфигов, 
нежели полноценным системным софтом, который стоило бы класть в /usr/bin. Но 
из-за того, что хаскель вынуждает меня создавать песочницу и полноценный проект 
для них, то ему не место в конфигах (/etc). В конце концов, в системе может 
быть специальное место для компиляций, чтобы снизить нагрузку на SSD. Если 
пользователь захочет добавить свою компилируемую программу, то следует 
добавлять её в /usr/local


Не получилось использовать Control.Concurrent так как в программе, порождённой 
GHC, только главная нить может завершить процесс и при этом завершаются все 
дочерние нити.

Проще сделать двумя отдельными процессами: первый стартует второй и слушает его 
stdout в поисках желанной строки. Если она встречена, то первый процесс 
завершается (надо проверить, не умрёт ли дочерний процесс). Дочерний процесс 
читает стандартный вывод wpa и проксирует его на свой стандартный вывод и в 
syslog. После завершения первого процесса второй должен продолжить своё 
существование, пока читается стандартный вывод wpa.


wpa_daemon
   Фронтэнд к wpa_supplicant. Отправляет его stdout+stderr в syslog
   В остальном пытается быть прозрачным:
   - передаёт собственные аргументы вызова в wpa_supplicant;
   - stdout+stderr проксируется на собственный stdout;
   - проксирует код возврата;

wpa_start
   Запускает wpa_daemon и проксирует его стандартный вывод пока не встретит 
   ключевое слово, означающее окончание настройки соединения. После этого 
   фронтэнд умирает оставляя демон работать фоново.
