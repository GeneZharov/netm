wpa_start
   Запускает wpa_daemon и проксирует его стандартный вывод пока не встретит 
   ключевое слово, означающее окончание настройки соединения. После этого 
   фронтэнд умирает оставляя демон работать фоново.

wpa_daemon (DaemonTerm)
   Фронтэнд к wpa_supplicant. Отправляет его stdout+stderr в syslog
   В остальном пытается быть прозрачным:
   - передаёт собственные аргументы вызова в wpa_supplicant;
   - stdout и stderr проксируются на собственный stdout и stderr;
   - проксирует код возврата;

wpa_daemon
   Версия без псевдотерминала. Разрабатывал, так как была проблема с 
   псевдотерминальной версией: после системного suspend процесс wpa_supplicant 
   иногда подвисал и становился невоспреимчив к любым сигналам.


┃ Сигналы
   Если фронтэнд просто тихо умрёт, то в демоне будет сломан канал stdout, о 
   чём он незамедлительно сообщит на stderr. Чтобы этого не было, надо 
   предварительно закрыть stdout в демоне. Поэтому перед смертью frontend 
   посылает демону сигнал USR1 о том, что пора демонизироваться.


Использование хаскеля для этой задачи оправдано, так как эти обёртки над 
wpa_supplicant — на самом деле являются системным софтом. Они постоянно висят в 
памяти, поэтому её расход должен быть оптимизирован.

Эта пара скриптов является скорее продолжением пользовательских конфигов, 
нежели полноценным системным софтом, который стоило бы класть в /usr/bin. Но 
из-за того, что хаскель вынуждает меня создавать песочницу и полноценный проект 
для них, то ему не место в конфигах (/etc). В конце концов, в системе может 
быть специальное место для компиляций, чтобы снизить нагрузку на SSD. Если 
пользователь захочет добавить свою компилируемую программу, то следует 
добавлять её в /usr/local


Не получилось использовать Control.Concurrent так как в программе, порождённой 
GHC, только главная нить может завершить процесс и при этом завершаются все 
дочерние нити.

Проще сделать двумя отдельными процессами: первый стартует второй и слушает его 
stdout в поисках желанной строки. Если она встречена, то первый процесс 
завершается (надо проверить, не умрёт ли дочерний процесс). Дочерний процесс 
читает стандартный вывод wpa и проксирует его на свой стандартный вывод и в 
syslog. После завершения первого процесса второй должен продолжить своё 
существование, пока читается стандартный вывод wpa.


┃ Вывод wpa_supplicant
   Вывод, который wpa_supplicant генерит в терминал по умолчанию конечно 
   лаконичный, но если он не может найти нужную точку доступа, то пользователь 
   видит только: Successfully initialized wpa_supplicant

   Если использовать ключ -d для повышения словесности в сочетании с -s 
   (syslog) или -f (в файл), куда и скидывать весь этот флуд, то в терминал 
   вообще не пишется ничего полезного.

   Самый простой и универсальный способ решить эту проблему: повысить 
   словесность wpa_supplicant до желаемого уровня. Научить wpa_daemon прятать 
   вывод wpa_supplicant, если он слишком словесен и мешает пользователю. Вместо 
   этого можно просто выводить результат: удалось или не удалось подключиться.

   Более сложным путём мог бы быть ключ -s и прослушивание syslog вместо 
   терминала. Либо отправка в файл (-f) и прослушивание файла, но я не уверен, 
   что прослушивание файла вообще реализуемо. К тому же такая множественность в 
   методах прослушивания логов слишком всё усложняет.
