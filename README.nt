Надо выводить пользоавателю (nets и при конфликтующих именах) не полное имя 
   файла, а часть после /etc/netm/ ? А может быть даже при старте скрипта, это 
   будет действительно нагляднее, хотя и менее очевидно.
Видимо надо wpa_start и wpa_daemon перенести в /etc/netm как продолжение 
   скрипта конфигурации и позиционировать их также как и другие утилиты из 
   _helpers ?
Почему я разрабатываю пакет для hackage, если это системный софт для родных 
   репозиториев ОС?



Не получилось использовать Control.Concurrent так как в программе, порождённой 
GHC, только главная нить может завершить процесс и при этом завершаются все 
дочерние нити.

Проще сделать двумя отдельными процессами: первый стартует второй и слушает его 
stdout в поисках желанной строки. Если она встречена, то первый процесс 
завершается (надо проверить, не умрёт ли дочерний процесс). Дочерний процесс 
читает стандартный вывод wpa и проксирует его на свой стандартный вывод и в 
syslog. После завершения первого процесса второй должен продолжить своё 
существование, пока читается стандартный вывод wpa.



┃ IO

   Можно настроить syslog на то, чтобы логи dhcp клались в отдельный файл.

   wpa_supplicant
      -B моментально форкается, не дожидаясь настройки соединения.
      -s писать в syslog вместо stdout. В генте эта фича не скомпилирована.
      -f писать в файл вместо stdout.
      По умолчанию не пишет ничего на стандартные потоки, если видит, что 
      запустили не из терминала (может по /dev/tty ?). Можно принудить его всё 
      таки выводить логи с помощью -d
   dhcpcd
      После того как настроит соединение, делает форк. До форка пишет на 
      stderr. Пишет все логи в syslog. -B для запрета форканья, при этом все 
      логи идут на stderr и в syslog.
   dhclient
      После того как настроит соединение, делает форк. С ключём -v перед форком 
      будет писать на stderr, иначе вообще ничего не пишет на стандартные 
      потоки. Пишет все логи в syslog. -nw для того чтобы форк был сделан 
      сразу, без ожидания пока настроится соединение.


┃ Команды

   # new
      netn ξ ξ ξ... — остановить все соединения и поднять заданные

   # up
      netu ξ ξ ξ... — остановить заданные соединения и поднять снова
      netu — остановить все работающие соединения и поднять снова

   # down
      netd ξ ξ ξ... — остановить заданные соединения
      netd — остановить все работащие соединения

   # status
      nets — показать ныне работающие соединения


┃ Все возможные задачи
   • Опустить все соединения и поднять набор новых.
      │ В новом месте после долгого перерыва, когда я уже не помню что сейчас 
      │ работает и с чем конфликтует.
   • Показать текущие соединения.
   • Дополнительно поднять одно соединение или опустить одно соединение.
      │ Включить/выключить яндексовый vpn, чтобы не грузить яндексовые сети, 
      │ когда мне не нужны их сервисы и вообще не хочется там светиться.
   • Перезапустить текущие соединения.
      │ Почти всегда помогает, если внезапно отвалился инэт и не хочется 
      │ разбираться.
   • Опустить все соединения.
      │ Перед долгой автономной работой.


┃ Планировка команд для поднятия соединений
   Какие возможны варианты поднятия соединений:
   1) предварительно опускать все работающие соединения
   2) предварительно опускать только запрашиваемые работающие соединения
   3) предварительно не опускать работающие соединения

   3-я задача выглядит не обязательной и мало полезной. 2-я задача оправданна, 
   так как смысла поднимать уже работающее соединение действительно нет. К тому 
   же команда для перезапуска конкретного соединения кажется востребованной. 
   Таким образом удобно сделать отдельные команды для 1-й и 2-й задачи, а 3-ю 
   задачу отбросить как не нужную.

   Так как 2-я задача может использоваться для рестарта конкретных соединений, 
   то для единообразия её же использую для рестарта всех ныне имеющихся 
   соединений.


┃ Бездействие, если запрашиваемое соединение уже поднято
   Решил убрать функционал по бездействию в случае, если соединение уже 
   поднято:
      $ netu lair/wlan
         Это соединение уже поднято.
   так как практической пользы тут нет. Как правило, если я захотел сделать 
   такую штуку, то я вижу, что в действительности соединение не работает и 
   возможно не работают соответствующие процессы. Так что заявление о том, что 
   соединение уже поднято выглядит нелепо. Гораздо лучше прямо подчиниться 
   желанию пользователя — поднять соединение предварительно остановив возможную 
   предыдущую версию.


┃ Файлы

   /usr/local/src/netm/
      Haskell-исходники

   /usr/local/bin/...
      Haskell-бинарники

   /var/lib/netm/active
      Имена активных соединений.
      Просто имена каталогов через пробел.

   /etc/netm/
      Пользовательские настройки
      │ example1/...
      │ example2/...
      │ ...

   /etc/local.d/netm.start
      Восстановление соединений после перезагрузки. От полноценного скрипта 
      инициализации мало пользы, так как это будет урезанная версия команд, 
      доступных через бинарники. С другой стороны тоже самое можно сказать про 
      nginx, но они предоставляют нативные средста управления для каждой 
      системы.
