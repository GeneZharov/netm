wpa_daemon/
   frontend
   daemon

Не получилось использовать Control.Concurrent так как в программе, порождённой 
GHC, только главная нить может завершить процесс и при этом завершаются все 
дочерние нити.

Проще сделать двумя отдельными процессами: первый стартует второй и слушает его 
stdout в поисках желанной строки. Если она встречена, то первый процесс 
завершается (надо проверить, не умрёт ли дочерний процесс). Дочерний процесс 
читает стандартный вывод wpa и проксирует его на свой стандартный вывод и в 
syslog. После завершения первого процесса второй должен продолжить своё 
существование, пока читается стандартный вывод wpa.



┃ IO

   Можно настроить syslog на то, чтобы логи dhcp клались в отдельный файл.

   wpa_supplicant
      -B моментально форкается, не дожидаясь настройки соединения.
      -s писать в syslog вместо stdout. В генте эта фича не скомпилирована.
      -f писать в файл вместо stdout.
      По умолчанию не пишет ничего на стандартные потоки, если видит, что 
      запустили не из терминала (может по /dev/tty ?). Можно принудить его всё 
      таки выводить логи с помощью -d
   dhcpcd
      После того как настроит соединение, делает форк. До форка пишет на 
      stderr. Пишет все логи в syslog. -B для запрета форканья, при этом все 
      логи идут на stderr и в syslog.
   dhclient
      После того как настроит соединение, делает форк. С ключём -v перед форком 
      будет писать на stderr, иначе вообще ничего не пишет на стандартные 
      потоки. Пишет все логи в syslog. -nw для того чтобы форк был сделан 
      сразу, без ожидания пока настроится соединение.


Нужна утилита-фронтэнд, для запуска процессов. Она должна непрерывно вести 
запись в лог и при этом не завершать собственный процесс до тех пор, пока не 
будет встречана желаемая строка в стандартном выводе. После этого фронтэнд 
форкается и продолжает фоново писать в лог в то время как шэл-скрипт продолжит 
выполнение. Ну либо не форкается а как-то перенаправляет стандартный вывод 
ведомого процесса в файл, а сам завершается.



┃ TODO
   • лог wpa_supplicant не очищается;
   • лог dhcp вообще актуален во время работы процесса?
      Логи пишутся в системный лог.
   • Было бы удобно, если бы netu не завершался до тех пока соединение не будет 
      полностью настроено (dhcp). Иначе потом всё равно проверяешь 
      работоспособность пингом.
   • Может надо сделать уже нормальный информативный вывод о ходе подключения. 
      Чтобы сначала были логи wpa, потом dhcp, чтобы ошибки было хорошо видно, 
      а всякий мусор не писался.



┃ Команды

   # new
      netn ξ ξ ξ... — остановить все соединения и поднять заданные

   # up
      netu ξ ξ ξ... — поднять заданные соединения
      netu — перезапустить ныне работающие соединения

   # down
      netd ξ ξ ξ — остановить заданные соединения
      netd — остановить ныне работащие соединения

   # status
      nets — показать ныне работающие соединения

   Имена конфигов можно задать не полностью. К ним потом будет добавляться .* и 
   с помощью shell pattern извлекать имя первого файла.



┃ Все возможные задачи
   • Опустить все соединения и поднять набор новых.
      │ В новом месте после долгого перерыва, когда я уже не помню что сейчас 
      │ работает и с чем конфликтует.
   • Показать текущие соединения.
   • Дополнительно поднять одно соединение или опустить одно соединение.
      │ Включить/выключить яндексовый vpn, чтобы не грузить яндексовые сети, 
      │ когда мне не нужны их сервисы и вообще не хочется там светиться.
   • Перезапустить текущие соединения.
      │ Почти всегда помогает, если внезапно отвалился инэт и не хочется 
      │ разбираться.
   • Опустить все соединения.
      │ Перед долгой автономной работой.



┃ Бездействие, если запрашиваемое соединение уже поднято
   Решил убрать функционал по бездействию в случае, если соединение уже 
   поднято:
      $ netu lair/wlan
         Это соединение уже поднято.
   так как практической пользы тут нет. Как правило, если я захотел сделать 
   такую штуку, то я вижу, что в действительности соединение не работает и 
   возможно не работают соответствующие процессы. Так что заявление о том, что 
   соединение уже поднято выглядит нелепо. Гораздо лучше прямо подчиниться 
   желанию пользователя — поднять соединение предварительно остановив возможную 
   предыдущую версию.



┃ Файлы

   /usr/local/src/netm/
      Haskell-исходники

   /usr/local/bin/...
      Haskell-бинарники

   /var/lib/netm/active
      Имена активных соединений.
      Просто имена каталогов через пробел.

   /etc/netm/
      Пользовательские настройки
      │ example1/...
      │ example2/...
      │ ...

   /etc/local.d/netm.start
      Восстановление соединений после перезагрузки. От полноценного скрипта 
      инициализации мало пользы, так как это будет урезанная версия команд, 
      доступных через бинарники. С другой стороны тоже самое можно сказать про 
      nginx, но они предоставляют нативные средста управления для каждой 
      системы.
